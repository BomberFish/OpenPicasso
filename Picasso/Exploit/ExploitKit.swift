//
//  Exploit.swift
//  Picasso
//
//  Created by Hariz Shirazi on 2023-08-12.
//

import Foundation

/// `ExploitKit`*/*`AbsoluteSolver` 2.0:  File overwrite exploit class that can be extended to support more exploits in the future.
public class ExploitKit: ObservableObject { // still debating the observableobject thing
    static var shared = ExploitKit()
    
    /// **REMEMBER TO SET AT APP LAUNCH:** If app is running with TrollStore
    @Published var isTrollStore: Bool = false
    
    /// Which exploit is being used.
    @Published var selectedExploit: ExploitType = .kfd
    
    /// If the user has used KFD before.
    @Published var hasUsedKFDBefore: Bool = false
    
    /// If the selected exploit has system overwrite.
    @Published var hasSystemOverwrite: Bool = false
    
    @Published var compatibleExploits: [ExploitType]  = [.none]
    
    init() {
        if FileManager.default.isReadableFile(atPath: "/var") || (try? FileManager.default.contentsOfDirectory(at:  Bundle.main.bundleURL.deletingLastPathComponent(), includingPropertiesForKeys: nil).contains(where: {$0.path.localizedStandardContains("_TrollStore")})) ?? false {
            print("Running under TrollStore.")
            isTrollStore = true
        }
    }
    
    /// Get exploits compatible with the device
    func GetCompatibleExploits() -> [ExploitType] {
        var exploits: [ExploitType] = [.none]
        let largeVer = ProcessInfo.processInfo.operatingSystemVersionString
        let verComponents = largeVer.components(separatedBy: ["(", " ", ")"])
//            if #available(iOS 16.3, *) {
//                if #available(iOS 16.5.1, *) {
//                    if UIDevice.current.systemVersion == "16.6", verComponents.count >= 4, verComponents[4] == "20G5026e" {
//                        //16.6b1
//                        exploits.append(.kfd)
//                    }
//                } else {
//                    //16.3-16.5.0
//                    exploits.append(.kfd)
//                }
//            } else {
//                if UIDevice.current.systemVersion == "16.2", verComponents.count >= 4, !["20C5032e", "20C5043e"].contains(verComponents[4]) {
//                    // 16.2rc
//                    exploits.append(.kfd)
//                } else {
//                    if #available(iOS 15, *) {
//                        // 15.0-16.1.2, 16.2db1/2
//                        exploits.append(.mdc)
//                        if #available(iOS 16, *) {
//                            // 16.0-16.1.2
//                            print("Version is kfd compatible")
//                            exploits.append(.kfd) // only 16.x is compatible with kfd
//                        }
//                    }
//                }
//            }
        
        if #unavailable(iOS 17.0) { // 17.0+ has no known exploits (yet... alfie please work on mdc2)
            if #unavailable(iOS 16.0) {
                if #unavailable(iOS 15.7.2) { // mdc patched in 15.7.2
                    exploits.append(.mdc) // ios 15.0-15.7.1
                }
            } else {
                exploits.append(.kfd) // 16.0+, no extra checks necessary since apple seems to be ignoring landa...
                if #unavailable(iOS 16.2) {
                    exploits.append(.mdc) // 16.0-16.1.2
                }
                
                if UIDevice.current.systemVersion == "16.2", verComponents.count >= 4, ["20C5032e", "20C5043e"].contains(verComponents[4]) {
                    exploits.append(.mdc) // 16.2 dev beta 1/2
                }
            }
        }
        return exploits
    }
    
    /// Automatically selects best exploit for the OS version, unless user specifies otherwise.
    func SelectExploit() {
        print("SelectExploit() called")
        let userChoice = UserDefaults.standard.string(forKey: "currentExploit")
        let largeVer = ProcessInfo.processInfo.operatingSystemVersionString
        let verComponents = largeVer.components(separatedBy: ["(", " ", ")"])
        self.compatibleExploits = [.none]
        
        if let userChoice {
            self.selectedExploit = .init(rawValue: userChoice) ?? .none
        } else {
            if #available(iOS 16.3, *) {
                if #available(iOS 16.5.1, *) {
                    if UIDevice.current.systemVersion == "16.6", verComponents.count >= 4, verComponents[4] == "20G5026e" {
                        //16.6b1
                        print("Selecting kfd")
                        self.selectedExploit = .kfd
                        self.compatibleExploits.append(.kfd)
                    } else {
                        print("Selecting none")
                        //Too new (16.5.1rc)
                        self.selectedExploit = .none
                    }
                } else {
                    //16.3-16.5.0
                    print("Selecting kfd")
                    self.selectedExploit = .kfd
                    self.compatibleExploits.append(.kfd)
                }
            } else {
                if UIDevice.current.systemVersion == "16.2", verComponents.count >= 4, !["20C5032e", "20C5043e"].contains(verComponents[4]) {
                    // 16.2rc
                    print("Selecting kfd")
                    self.selectedExploit = .kfd
                    self.compatibleExploits.append(.kfd)
                } else {
                    if #available(iOS 15, *) {
                        // 15.0-16.1.2, 16.2db1/2
                        print("Selecting mdc")
                        self.selectedExploit = .mdc
                        self.compatibleExploits.append(.mdc)
                        
                        if #available(iOS 16, *) {
                            // 16.0-16.1.2
                            print("Version is kfd compatible")
                            self.compatibleExploits.append(.kfd) // only 16.x is compatible with kfd
                        }
                    } else {
                        // Too old (under 15)
                        print("wtf")
                        self.selectedExploit = .none // FIXME: This shouldn't even be possible, the minimum deployment target is 15.0
                    }
                }
            }
        }
        
        if self.selectedExploit == .kfd || self.selectedExploit == .mdc {
            hasSystemOverwrite = true
        }
        
        print("[ExploitKit] \(self.selectedExploit.rawValue.uppercased()) auto-selected by AbsoluteSolver3.0.")
    }
    
    /// Get the recommended exploit
    func GetRecommendedExploit() -> ExploitType {
        let userChoice = UserDefaults.standard.string(forKey: "currentExploit")
        let largeVer = ProcessInfo.processInfo.operatingSystemVersionString
        let verComponents = largeVer.components(separatedBy: ["(", " ", ")"])
            if #available(iOS 16.3, *) {
                if #available(iOS 16.5.1, *) {
                    if UIDevice.current.systemVersion == "16.6", verComponents.count >= 4, verComponents[4] == "20G5026e" {
                        //16.6b1
                        return .kfd
                    } else {
                        //Too new (16.5.1rc)
                        return .none
                    }
                } else {
                    //16.3-16.5.0
                    return .kfd
                }
            } else {
                if UIDevice.current.systemVersion == "16.2", verComponents.count >= 4, !["20C5032e", "20C5043e"].contains(verComponents[4]) {
                    // 16.2rc
                    return .kfd
                } else {
                    if #available(iOS 15, *) {
                        // 15.0-16.1.2, 16.2db1/2
                        return .mdc
                    } else {
                        // Too old (under 15)
                        return .none // FIXME: This shouldn't even be possible, the minimum deployment target is 15.0
                    }
                }
            }
    }
    
    /// Perform any actions required to initialize an exploit.
    func Initialize() throws {
        print("[ExploitKit] Initializing...")
        switch selectedExploit { // look mum i know switch statements
        case .kfd:
            print("[ExploitKit] Using KFD, performing kopen...")
            KFD.kopen()
            hasUsedKFDBefore = true
        case .mdc:
            if isTrollStore {
                print("[ExploitKit] TrollStore detected, no sandbox escape needed")
            } else {
                print("[ExploitKit] Using MDC, escaping sandbox...")
                var returnedError: Error?
                grant_full_disk_access { error in
                    returnedError = error
                }
                
                if returnedError != nil {
                    throw returnedError!
                }
            }
        case .none:
            print("[ExploitKit] No exploit selected")
        }
    }
    
    /// Gets contents of given directory.
    /// > Warning: `orig_to_v_data` will be nil if MDC/TS is used. Make sure to check for this in code to avoid causing crashes or panics when using MDC.
    func GetContentsOfDirectory(_ at: URL) throws -> (contents: [URL], orig_to_v_data: UInt64?) {
        let fm: FileManager = .default
        
        if isTrollStore || selectedExploit == .mdc {
            do {
                return (try fm.contentsOfDirectory(at: at, includingPropertiesForKeys: nil), nil)
            } catch {
                throw error
            }
        } else if selectedExploit == .kfd {
            print("[ExploitKit] Attempting FileManager for directory \(at.path)")
            guard let contents = try? fm.contentsOfDirectory(at: at, includingPropertiesForKeys: nil) else {
                do {
                    print("[ExploitKit] FileManager failed, using KFD.")
                    let mount = try KFD.mountFolderAtURL(at)
                    print("[ExploitKit] Remount successful, getting contents.")
                    return try (fm.contentsOfDirectory(at: mount.mountURL, includingPropertiesForKeys: nil), mount.orig_to_v_data)
                } catch {
                    print("[!] [ExploitKit] \(error)")
                    throw error
                }
            }
            print("[ExploitKit] FileManager was successful!")
            return (contents, nil)
        } else {
            throw unexpectedErrorString
        }
    }
    
    /// Perform actions before exiting to prevent any future error.
    public func CleanUp() {
        print("[ExploitKit] Cleanup ")
        
        // ok not a problem
        if hasUsedKFDBefore {
            KFD.kclose()
        }
    }
    
    /// Overwrite a file with any data.
    public func Overwrite(at url: URL, with data: Data, unlockDataAtEnd: Bool = false, multipleIterations: Bool = false) throws {
        let isVar: Bool = (url.pathComponents[safe: 0] == "/" && url.pathComponents[safe: 1] == "")
        let isWritable: Bool = FileManager.default.isWritableFile(atPath: url.path)
        print("[ExploitKit] \(url.pathComponents[0]), \(isVar)")
        switch selectedExploit {
        case .kfd:
            if isVar && !isWritable {
                do {
                    guard let filename: String = url.pathComponents.last else {
                        throw "URL is empty?!"
                    }
                    
                    print("[AbsoluteSolver2.0] Mounting folder...")
                    let mount = try KFD.mountFolderAtURL(url.deletingLastPathComponent())
                    let overwriteURL = mount.mountURL.appendingPathComponent(filename)
                    
                    do {
                        print("[AbsoluteSolver2.0] Using KFD to write")
                        try KFD.overwriteFile(at: overwriteURL, with: data, unlockDataAtEnd: unlockDataAtEnd, multipleIterations: multipleIterations)
                        print("[AbsoluteSolver2.0] Overwrite succeeded, unmounting folder...")
                        try KFD.unmountFileAtURL(mountURL: mount.mountURL, orig_to_v_data: mount.orig_to_v_data)
                    } catch {
                        print("[AbsoluteSolver2.0] Unmounting on failure...")
                        try? KFD.unmountFileAtURL(mountURL: mount.mountURL, orig_to_v_data: mount.orig_to_v_data)
                        throw error
                    }
                } catch {
                    throw error
                }
            } else if isWritable {
                // this should work with ts2
                print("[AbsoluteSolver2.0] Using FileManager to write")
                do {
                    try data.write(to: url)
                } catch {
                    throw error
                }
            } else {
                print("[AbsoluteSolver2.0] Using KFD to write")
                do {
                    try KFD.overwriteFile(at: url, with: data, unlockDataAtEnd: unlockDataAtEnd, multipleIterations: multipleIterations)
                } catch {
                    throw error
                }
            }
        case .mdc:
            if isWritable {
                print("[AbsoluteSolver2.0] Using FileManager to write")
                do {
                    try data.write(to: url)
                } catch {
                    throw error
                }
            } else {
                do {
                    print("[AbsoluteSolver2.0] Using MDC to write")
                    try MDC.overwriteFile(at: url.path, with: data, unlockDataAtEnd: unlockDataAtEnd, multipleIterations: multipleIterations)
                } catch {
                    throw error
                }
            }
        case .none:
            if isWritable {
                do {
                    try data.write(to: url)
                } catch {
                    throw error
                }
            } else {
                do {
                    guard let strdata = String(data: data, encoding: .ascii) else { throw "File data could not be encoded." }
                    try TrollStoreRootHelper.write(strdata, to: url)
//                    throw "ExploitKit.Overwrite(at, with) is not implemented with ExploitType.none"
                } catch {
                    throw "Your device does not support this \"system\" tweak\(ExploitKit.shared.GetCompatibleExploits() == [.none] ? "" :  "Make sure to have an exploit enabled in the settings (MDC or KFD)"). Additionally, \(error.localizedDescription)"
                }
            }
        }
    }
    
    /// Overwrite a file with the data of another file.
    public func Overwrite(at url: URL, withFileAtURL: URL, unlockDataAtEnd: Bool = false, multipleIterations: Bool = false) throws {
        // Data(contentsOf: withFileAtURL)
        let isVar: Bool = (url.pathComponents[safe: 0] == "/" && url.pathComponents[safe: 1] == "")
        let isWritable: Bool = FileManager.default.isWritableFile(atPath: url.path)
        print("[ExploitKit] \(url.pathComponents[0]), \(isVar)")
        switch selectedExploit {
        case .kfd:
            if isVar && !isWritable {
                do {
                    guard let filename: String = url.pathComponents.last else {
                        throw "URL is empty?!"
                    }
                    
                    print("[AbsoluteSolver2.0] Mounting folder...")
                    let mount = try KFD.mountFolderAtURL(url.deletingLastPathComponent())
                    let overwriteURL = mount.mountURL.appendingPathComponent(filename)
                    
                    do {
                        print("[AbsoluteSolver2.0] Using KFD to write")
                        try KFD.overwriteFile(at: overwriteURL, withFileAtURL: withFileAtURL, unlockDataAtEnd: unlockDataAtEnd, multipleIterations: multipleIterations)
                        print("[AbsoluteSolver2.0] Overwrite succeeded, unmounting folder...")
                        try KFD.unmountFileAtURL(mountURL: mount.mountURL, orig_to_v_data: mount.orig_to_v_data)
                    } catch {
                        print("[AbsoluteSolver2.0] Unmounting on failure...")
                        try? KFD.unmountFileAtURL(mountURL: mount.mountURL, orig_to_v_data: mount.orig_to_v_data)
                        throw error
                    }
                } catch {
                    throw error
                }
            } else if isWritable {
                print("[AbsoluteSolver2.0] Using FileManager to write")
                do {
                    try Data(contentsOf: withFileAtURL).write(to: url)
                } catch {
                    throw error
                }
            } else {
                print("[AbsoluteSolver2.0] Using KFD to write")
                do {
                    try KFD.overwriteFile(at: url, withFileAtURL: withFileAtURL, unlockDataAtEnd: unlockDataAtEnd, multipleIterations: multipleIterations)
                } catch {
                    throw error
                }
            }
        case .mdc:
            if isWritable {
                print("[AbsoluteSolver2.0] Using FileManager to write")
                do {
                    try Data(contentsOf: withFileAtURL).write(to: url)
                } catch {
                    throw error
                }
            } else {
                do {
                    print("[AbsoluteSolver2.0] Using MDC to write")
                    try MDC.overwriteFile(at: url.path, with: Data(contentsOf: withFileAtURL), unlockDataAtEnd: unlockDataAtEnd, multipleIterations: multipleIterations)
                } catch {
                    throw error
                }
            }
        case .none:
            if isWritable {
                do {
                    try Data(contentsOf: withFileAtURL).write(to: url)
                } catch {
                    throw error
                }
            } else {
                do {
                    try TrollStoreRootHelper.copy(from: withFileAtURL, to: url)
                } catch {
                    throw "Your device does not support this \"system\" tweak. \(ExploitKit.shared.GetCompatibleExploits() == [.none] ? "" : "Make sure to have an exploit enabled in the settings (MDC or KFD)"). Additionally, \(error.localizedDescription)"
                }
            }
        }
    }
    
    func ExploitTypeToName(_ type: ExploitType) -> String {
        switch type {
        case .kfd:
            return "KFD"
        case .mdc:
            return "MDC"
        case .none:
            return "None (Advanced)"
        }
    }
    
    public func toggleCatalogCorruption(at url: URL, corrupt: Bool, usingExploit: Bool) throws {
        let fd = open(url.path, O_RDONLY | O_CLOEXEC)
        guard fd != -1 else { throw "Could not open target file" }
        defer { close(fd) }
        
        let buffer = UnsafeMutablePointer<Int>.allocate(capacity: 0x4000)
        let n = read(fd, buffer, 0x4000)
        var byteArray = [UInt8](Data(bytes: buffer, count: n))
        
        
        let treeBytes: [UInt8] = [0,0,0,0, 0x74,0x72,0x65,0x65, 0,0,0]
        let corruptBytes: [UInt8] = [0x50,0x69,0x63,0x61,0x73,0x73,0x6F,0x50,0x69,0x63,0x61]
        
        let findBytes = corrupt ? treeBytes : corruptBytes
        let replaceBytes = corrupt ? corruptBytes : treeBytes
        
        var startIndex = 0
        var found = false
        while startIndex <= byteArray.count - findBytes.count {
            let endIndex = startIndex + findBytes.count
            let subArray = Array(byteArray[startIndex..<endIndex])
            
            if subArray == findBytes {
                byteArray.replaceSubrange(startIndex..<endIndex, with: replaceBytes)
                startIndex += replaceBytes.count
                found = true
                break
            } else {
                startIndex += 1
            }
        }
        
        guard found else { return }
        
        if usingExploit && (selectedExploit == .kfd || selectedExploit == .mdc) {
            switch selectedExploit {
            case .mdc:
                let overwriteSucceeded = byteArray.withUnsafeBytes { dataChunkBytes in
                    return unaligned_copy_switch_race(
                        fd, 0, dataChunkBytes.baseAddress, dataChunkBytes.count, true)
                }
            case .kfd:
                print("\(byteArray.count) \(byteArray)")
//                sleep(1)
                try KFD.overwriteFile(at: url, with: Data(byteArray))
                print("success")
            case .none: break
            }
        }
    }
}

/// A type of exploit.
public enum ExploitType: String, Hashable {
    case kfd
    case mdc
    case none
}
